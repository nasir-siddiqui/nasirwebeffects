<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grandmaster Chess Bot</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome for Chess Pieces -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Chess.js Library for Game Logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <style>
        /* Custom Board Styles */
        .board-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 600px;
            border: 5px solid #475569;
            user-select: none;
            -webkit-user-select: none;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5rem, 5vw, 3rem);
            cursor: pointer;
            position: relative;
        }

        .white-square { background-color: #f0d9b5; color: #b58863; }
        .black-square { background-color: #b58863; color: #f0d9b5; }

        /* Piece Colors when using FontAwesome text */
        .piece-w { color: #fff; text-shadow: 0 0 2px #000; }
        .piece-b { color: #000; text-shadow: 0 0 1px #fff; }

        /* Highlights */
        .highlight { position: relative; }
        .highlight::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }
        .selected { background-color: #bbc462 !important; }
        .last-move { background-color: #aaa23a !important; }
        
        /* Capturable hint */
        .capture-hint {
            box-shadow: inset 0 0 0 4px rgba(0,0,0,0.2);
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 min-h-screen flex flex-col items-center justify-center p-4 font-sans">

    <div class="w-full max-w-4xl flex flex-col lg:flex-row gap-8 items-start justify-center">
        
        <!-- Left Panel: Game Info -->
        <div class="w-full lg:w-1/3 flex flex-col gap-4 order-2 lg:order-1">
            <div class="bg-slate-800 p-6 rounded-xl shadow-lg border border-slate-700">
                <h1 class="text-3xl font-bold mb-2 text-blue-400"><i class="fas fa-chess-knight mr-2"></i>Chess AI</h1>
                <p class="text-slate-400 text-sm mb-4">Play against a Minimax bot (Depth 3).</p>
                
                <!-- Status Box -->
                <div id="status-box" class="bg-slate-700 p-4 rounded-lg mb-4 border-l-4 border-blue-500 transition-all">
                    <div class="text-lg font-semibold" id="status-text">White to move</div>
                    <div class="text-xs text-slate-400 mt-1" id="status-detail">Game ready.</div>
                </div>

                <!-- Controls -->
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="resetGame()" class="bg-blue-600 hover:bg-blue-500 text-white py-2 px-4 rounded transition shadow">
                        <i class="fas fa-redo mr-2"></i>New Game
                    </button>
                    <button onclick="undoMove()" class="bg-slate-600 hover:bg-slate-500 text-white py-2 px-4 rounded transition shadow">
                        <i class="fas fa-undo mr-2"></i>Undo
                    </button>
                </div>
                
                <div class="mt-4 flex items-center justify-between text-sm text-slate-400">
                    <span>Difficulty:</span>
                    <span class="text-green-400 font-mono">Intermediate</span>
                </div>
            </div>

            <!-- Move History (Last 5) -->
            <div class="bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700">
                <h3 class="font-semibold mb-2 text-slate-300">Last Moves</h3>
                <div id="move-history" class="font-mono text-sm h-24 overflow-y-auto text-slate-400">
                    <!-- populated by js -->
                </div>
            </div>
        </div>

        <!-- Center: The Board -->
        <div class="order-1 lg:order-2 w-full lg:w-auto flex justify-center">
            <div id="board" class="board-container shadow-2xl rounded-sm bg-slate-300">
                <!-- Squares generated by JS -->
            </div>
        </div>

    </div>

    <!-- Promotion Modal -->
    <div id="promotion-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50">
        <div class="bg-slate-800 p-6 rounded-xl shadow-2xl text-center border border-slate-600">
            <h2 class="text-2xl font-bold mb-6 text-white">Promote Pawn</h2>
            <div class="flex gap-4">
                <button onclick="promoteTo('q')" class="text-4xl text-white hover:text-blue-400 transition"><i class="fas fa-chess-queen"></i></button>
                <button onclick="promoteTo('r')" class="text-4xl text-white hover:text-blue-400 transition"><i class="fas fa-chess-rook"></i></button>
                <button onclick="promoteTo('b')" class="text-4xl text-white hover:text-blue-400 transition"><i class="fas fa-chess-bishop"></i></button>
                <button onclick="promoteTo('n')" class="text-4xl text-white hover:text-blue-400 transition"><i class="fas fa-chess-knight"></i></button>
            </div>
        </div>
    </div>

    <script>
        // --- GAME CONFIGURATION & STATE ---
        var game = new Chess();
        var boardEl = document.getElementById('board');
        var statusTextEl = document.getElementById('status-text');
        var statusDetailEl = document.getElementById('status-detail');
        var moveHistoryEl = document.getElementById('move-history');
        var selectedSquare = null;
        var pendingPromotionMove = null;
        var playerColor = 'w'; // Human is white

        // --- PIECE ICONS MAPPING ---
        const pieceIcons = {
            'w': { 'p': 'fa-chess-pawn', 'n': 'fa-chess-knight', 'b': 'fa-chess-bishop', 'r': 'fa-chess-rook', 'q': 'fa-chess-queen', 'k': 'fa-chess-king' },
            'b': { 'p': 'fa-chess-pawn', 'n': 'fa-chess-knight', 'b': 'fa-chess-bishop', 'r': 'fa-chess-rook', 'q': 'fa-chess-queen', 'k': 'fa-chess-king' }
        };

        // --- AI / BOT LOGIC (Minimax + AlphaBeta + PST) ---
        
        // Piece values
        const weights = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };
        
        // Piece-Square Tables (PST) - Encodes positional strategy
        // Higher numbers = better squares for that piece
        const pst_w = {
            'p': [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ],
            'n': [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            'b': [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            'r': [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ],
            'q': [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            'k': [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ]
        };

        // Mirror PST for Black
        const pst_b = {};
        for (let key in pst_w) {
            pst_b[key] = pst_w[key].slice().reverse();
        }

        function evaluateBoard(gameBoard) {
            let totalEvaluation = 0;
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    totalEvaluation = totalEvaluation + getPieceValue(gameBoard[i][j], i, j);
                }
            }
            return totalEvaluation;
        }

        function getPieceValue(piece, x, y) {
            if (piece === null) return 0;
            
            // x and y are 0-7 (rank and file indices)
            // Note: Chess.js board is [rank][file], where rank 0 is '8' and rank 7 is '1'
            // Our PSTs are defined from visual top (Black side) to bottom (White side) 
            // if we consider array index 0 as top.
            
            // To make it easier:
            // row 0 in chess.js board = rank 8 (Black backrank)
            // row 7 in chess.js board = rank 1 (White backrank)

            // We need to be careful with indexing. 
            // The defined PSTs (pst_w) assume index 0 is "top of board" (Rank 8) for White? 
            // Actually, standard PSTs usually define Rank 0 as 'Rank 1'. 
            // Let's simplify: For White, Row 7 is Backrank. For Black, Row 0 is Backrank.
            
            // Let's just use the raw array indices and flip the table access logic.
            // pst_w[0] corresponds to Rank 8 (Far side for white).
            
            let absoluteValue = weights[piece.type];
            let pieceValue = 0;

            if (piece.color === 'w') {
                pieceValue = absoluteValue + pst_w[piece.type][x][y]; // x is row, y is col
            } else {
                pieceValue = absoluteValue + pst_b[piece.type][x][y];
            }

            return piece.color === 'w' ? pieceValue : -pieceValue;
        }

        // Minimax with Alpha-Beta Pruning
        function minimax(game, depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board());
            }

            const newGameMoves = game.moves();

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (let i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    let eval = minimax(game, depth - 1, alpha, beta, false);
                    game.undo();
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) return maxEval;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    let eval = minimax(game, depth - 1, alpha, beta, true);
                    game.undo();
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) return minEval;
                }
                return minEval;
            }
        }

        function makeBestMove() {
            if (game.game_over()) return;

            statusTextEl.innerHTML = 'AI Thinking... <div class="loader ml-2"></div>';
            
            // Use setTimeout to allow UI to render the "Thinking" state
            setTimeout(() => {
                let bestMove = null;
                let bestValue = Infinity; // Black wants to minimize score (White positive, Black negative)
                let moves = game.moves();
                
                // Shuffle moves to add randomness if values are equal
                moves.sort(() => Math.random() - 0.5);

                // Optimization: Order moves by captures first (simple heuristic)
                // In a real engine, this is crucial. Here we just random shuffle.

                for (let i = 0; i < moves.length; i++) {
                    game.move(moves[i]);
                    // Depth 3 is decent balance of speed/skill for JS
                    let boardValue = minimax(game, 3, -Infinity, Infinity, true); 
                    game.undo();
                    
                    if (boardValue < bestValue) {
                        bestValue = boardValue;
                        bestMove = moves[i];
                    }
                }

                game.move(bestMove);
                updateStatus();
                renderBoard();
                playMoveSound();
            }, 100);
        }


        // --- BOARD RENDERING & INTERACTION ---

        function initBoard() {
            renderBoard();
            updateStatus();
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            const board = game.board(); // 8x8 array
            
            // Last move highlighting
            let lastMove = game.history({ verbose: true }).pop();
            let lastFrom = lastMove ? lastMove.from : null;
            let lastTo = lastMove ? lastMove.to : null;

            // Valid moves for selected piece
            let validMoves = [];
            if (selectedSquare) {
                validMoves = game.moves({ square: selectedSquare, verbose: true }).map(m => m.to);
            }

            // Loop rows
            for (let i = 0; i < 8; i++) {
                // Loop columns
                for (let j = 0; j < 8; j++) {
                    const squareEl = document.createElement('div');
                    const squareId = String.fromCharCode(97 + j) + (8 - i); // e.g., 'a8'
                    
                    // Classes
                    let classes = ['square'];
                    // Color
                    if ((i + j) % 2 === 0) classes.push('white-square');
                    else classes.push('black-square');

                    // Highlights
                    if (selectedSquare === squareId) classes.push('selected');
                    if (validMoves.includes(squareId)) {
                        classes.push('highlight');
                        // Check if capture
                        const targetPiece = game.get(squareId);
                        if (targetPiece) classes.push('capture-hint');
                    }
                    if (squareId === lastFrom || squareId === lastTo) classes.push('last-move');

                    squareEl.className = classes.join(' ');
                    squareEl.dataset.square = squareId;
                    
                    // Click Handler
                    squareEl.onclick = () => handleSquareClick(squareId);

                    // Piece Render
                    const piece = board[i][j];
                    if (piece) {
                        const pieceIcon = document.createElement('i');
                        pieceIcon.className = `fas ${pieceIcons[piece.color][piece.type]} piece-${piece.color}`;
                        squareEl.appendChild(pieceIcon);
                    }
                    
                    // Coordinate Labels (optional polish)
                    if (j === 0) { // Rank numbers on left
                        const rank = document.createElement('span');
                        rank.innerText = 8 - i;
                        rank.className = "absolute top-0 left-1 text-[10px] font-bold opacity-50";
                        if ((i + j) % 2 === 0) rank.style.color = "#b58863";
                        else rank.style.color = "#f0d9b5";
                        squareEl.appendChild(rank);
                    }
                    if (i === 7) { // File letters on bottom
                        const file = document.createElement('span');
                        file.innerText = String.fromCharCode(97 + j);
                        file.className = "absolute bottom-0 right-1 text-[10px] font-bold opacity-50";
                         if ((i + j) % 2 === 0) file.style.color = "#b58863";
                        else file.style.color = "#f0d9b5";
                        squareEl.appendChild(file);
                    }

                    boardEl.appendChild(squareEl);
                }
            }
        }

        function handleSquareClick(square) {
            // If game over or bot turn, ignore
            if (game.game_over() || (game.turn() === 'b' && !game.game_over())) return;

            // If clicking the same square, deselect
            if (selectedSquare === square) {
                selectedSquare = null;
                renderBoard();
                return;
            }

            // If a piece is selected, try to move
            if (selectedSquare) {
                const moves = game.moves({ square: selectedSquare, verbose: true });
                const move = moves.find(m => m.to === square);

                if (move) {
                    // Check for promotion
                    if (move.flags.includes('p') || move.flags.includes('cp')) { // p=promotion, cp=capture promotion
                        pendingPromotionMove = { from: selectedSquare, to: square };
                        document.getElementById('promotion-modal').classList.remove('hidden');
                        return;
                    }

                    // Make Move
                    game.move({ from: selectedSquare, to: square });
                    selectedSquare = null;
                    postMoveActions();
                } else {
                    // Invalid move, check if clicking another own piece
                    const piece = game.get(square);
                    if (piece && piece.color === game.turn()) {
                        selectedSquare = square;
                        renderBoard();
                    } else {
                        selectedSquare = null;
                        renderBoard();
                    }
                }
            } else {
                // Select a piece
                const piece = game.get(square);
                if (piece && piece.color === game.turn()) {
                    selectedSquare = square;
                    renderBoard();
                }
            }
        }

        function promoteTo(type) {
            if (!pendingPromotionMove) return;
            
            game.move({
                from: pendingPromotionMove.from,
                to: pendingPromotionMove.to,
                promotion: type
            });
            
            document.getElementById('promotion-modal').classList.add('hidden');
            pendingPromotionMove = null;
            selectedSquare = null;
            postMoveActions();
        }

        function postMoveActions() {
            playMoveSound();
            renderBoard();
            updateStatus();
            updateHistory();
            
            if (!game.game_over()) {
                // Trigger Bot
                makeBestMove();
            }
        }

        function updateStatus() {
            let status = '';
            let detail = '';

            let moveColor = (game.turn() === 'b') ? "Black" : "White";

            if (game.in_checkmate()) {
                status = `Game Over: ${moveColor === 'White' ? "Black" : "White"} Wins!`;
                detail = 'Checkmate';
                statusTextEl.className = "text-lg font-bold text-red-400";
            } else if (game.in_draw()) {
                status = 'Game Over: Draw';
                detail = 'Stalemate or Insufficient Material';
                statusTextEl.className = "text-lg font-bold text-yellow-400";
            } else {
                status = `${moveColor} to move`;
                if (game.in_check()) {
                    status += ' (CHECK!)';
                    statusTextEl.className = "text-lg font-bold text-orange-400";
                } else {
                    statusTextEl.className = "text-lg font-semibold text-white";
                }
                
                if(moveColor === 'White') detail = 'Your turn.';
                else detail = 'AI is calculating...';
            }

            statusTextEl.innerHTML = status;
            statusDetailEl.innerText = detail;
        }

        function updateHistory() {
            const history = game.history();
            // Show last 10 moves formatted
            let html = '';
            for(let i=0; i<history.length; i+=2) {
                html += `<div class="flex justify-between mb-1 border-b border-slate-700 pb-1">
                    <span class="text-slate-500 w-8">${(i/2)+1}.</span>
                    <span class="text-blue-300 w-16">${history[i]}</span>
                    <span class="text-red-300 w-16 text-right">${history[i+1] || ''}</span>
                </div>`;
            }
            moveHistoryEl.innerHTML = html;
            moveHistoryEl.scrollTop = moveHistoryEl.scrollHeight;
        }

        function resetGame() {
            game.reset();
            selectedSquare = null;
            statusTextEl.className = "text-lg font-semibold text-white";
            moveHistoryEl.innerHTML = '';
            initBoard();
        }

        function undoMove() {
            // Undo twice (Bot move then Human move) to get back to Human turn
            game.undo(); 
            game.undo();
            selectedSquare = null;
            renderBoard();
            updateStatus();
            updateHistory();
        }

        function playMoveSound() {
            // Simple synthetic sound so we don't need external assets
            // Not supported in all contexts, but fails silently
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(game.turn() === 'b' ? 800 : 600, ctx.currentTime); // High pitch for white move, lower for bot
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            } catch (e) {
                // Audio context might be blocked
            }
        }

        // Start
        initBoard();

    </script>
</body>
</html>
